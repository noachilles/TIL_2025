'''
내가 짠 코드의 메모리가 크고 시간이 느린 이유를 찾아가자..
아마 딕셔너리 써서 그런 거겠지 ㅠ 으흑 따흐흐흐흐흑
가지치기 미숙해서!!!!!!!!!!!!!!!!!!! + dictionary 사용해서!!!!!!!!!!!!!!!!!!
'''

def f():
    '''1. 조사 규칙 정리
        모든 후보군에 대해서 조사한다
            이 때, 코어의 순서가 중요할까? => 이런 생각이 들면 검증을 해야한다.
        모든 후보군에 대해서 다 조사를 출발시켰는가?
            - 종료조건은 내가 지금 몇 번째 후보군을 조사하고 있는지
            - 다음 조사에 영향을 미치지 않도록 전선이었던 것을 지울 수도 있어야 함
                : 원복시킬 수 있는 방법을 생각해야 -> 백트래킹
                    재귀 형식인가?! -> overstack flow를 검증
                    N이 작고, 조건이 간단해 limit 안 걸릴듯
            그 조사방식... 내가 점점 앞으로 나아가는 방식? 이것도 재귀로 해야하나?
                아니? 직선 범위 벗어날 때까지, 혹은 더 못 갈 때까지만!
        : 그 후보군을 선택하지 않는 경우도 생각해 봐야함
    '''

    '''99. 가지치기
        유망성 없는 경우는 무엇인가?
        1. 최대한 많은 코어 구하려는데
            -> 지금까지 선택한 코어 + 아직 선택 안 했지만 선택할 수도 있는 코어의 수가
            이미 예전에 구했던 최대 코어보다 작으면?!
        2. 코어가 최대한 많아야 하고, 전선은 최대한 짧아야 한다...?
            전선이 짧아야하니까... 누적된 코어가 최대 코어랑 같은데 전선이 이미 더 길다면 - 하지만 이건 섣부른 가지치기다!
    '''
    if 지금까지 선택한 코어 + 아직 선택 안 했지만 선택할 수도 있는 코어 < 최대 코어:
        유망성 X

    if 현재 조사중인 후보군 idx == R (모든 후보군의 개수만큼)
        '''99. 값 갱신
            누적코어 개수, 현재 찾은 최대 코어 개수 비교
            누적 코어 == 최대 코어
                전선이 더 짧을 때 전선만 갱신
            누적 코어 > 최대 코어
                최대 코어 개수 갱신
                전선도 갱신
        '''
    # 전수조사
    '''2. 이번 후보군에 대한 조사 방식
        이번 후보군이 누구? : 재귀형식으로 할 거니까 인자 추가
        이번 회차에서 전선 연결 가능한지 찾았으면
            그 전선 개수, 이번 후보군 코어 선택했으니까, 누적 인자 추가
    '''
    x, y -> candidate[r]
    for k > 4:
        nx + k
        ny + k

        temp_line >> []
        # 갈 수 있을 때까지 간다
        while 0 <= nx, ny <= N and data x, y == 0:
            temp_line + (nx, ny)
            # 전선을 이어나갈까? 원본을 바꿀까?
            # 원본을 지금 쭉~ 바꾸면 나중에 백트래킹해서 돌아왔을 때
            # 어디서부터 어디까지 0으로 돌려야?
            # 전선을 어느 좌표에 처리했는지 모아주면 안 되나
            nx + k, ny + k >> 한 방향으로 계속 이동
        # 한 방향으로 쭉 갔는데
        if 0 <= nx, ny < N: >> 여전히 cell 안에 있으면: 가장자리 도달 X
            continue        >> 이 방향으로는 전선을 연결할 수 없음

        # 끝까지 갔다면 - 그럼 모았던 전선을 모두 원본에 전선처리해서
        # 다음 조사에 영향 미치도록 해두기
        for line pos > temp_line:
            data line pos -> -1

        # 다음 후보군 선택하러 가기
        f(r++, acc_core++, acc_line+len(temp_line))

        # 조사갔다가 돌아왔다? 다음 선택지에 영향 안 미치도록 원복
        for temp_line:
            pos = 0
    # 이번 후보군 아예 선택 X
    f(r++ ... )

'''0. 규칙 정리
    첫번째, 셀 범위 밖으로 직선으로 연결
        최대한 많은 코어가 (모든 코어가 가능한지 조사)
    두번째. 가장자리에 있는 코어는 이미 연결되어 있다. (나의 탐색 조사 대상 X)
        이미 연결되어 있으니, 조사 대상 X이지만
        결과에는 영향을 미침 -> 시작할 때 코어가 이미 가장자리 개수만큼 초기화
    세번째. 전선은 교차 X
    네번째. 최대한 많은 코어, 최대한 짧은 전선
        최대한 짧은 전선? 나랑 가까운 벽 찾기? - 안 됨! 직접 보내야 한다(완탐)
'''

T
for tc -> 1, T
    N
    data -> N*N >> 0 cell, 1 core
    # 최종 출력 대상 초기화 - 가장 바보같은 선택지를 생각한다.
    r -> 전선의 길이: 최대한 짧아야 한다.: N * N
    c -> 코어의 개수: 0
    '''1. 조사를 위한 준비
        조사 대상(후보군) : 코어
        단, 가장자리가 아닌 코어들 대상
            반대로, 가장자리의 코어는? 초기값에 넣어두자.
    '''

    for x > N
        for y > N
            data x, y < 코어가 있음
                r-- < 전선 연결 못함
                if 가장자리인 경우
                    c++ <- 이미 확정된 코어임
                    data x, y <- -1로 변경 (조사 대상 X, 전선 연결 X)
            코어가 있고, 가장자리 아니면 후보군에 추가
    내가 가진 모든 후보군에 대해 조사
    len(후보군)만큼
    # 일단 전수조사