# 배열 (Array)  

배열은 내부에 포함된 각 데이터에 연속적인 메모리 공간을 할당함  
메모리 공간의 특정 값을 사용할 때에는 할당된 주소의 값을 참고한다.  

E라고 하는 값이 어디있는지 찾아야 하므로 탐색을 진행함  
가장 기본적인 방법은 선형 탐색  
=> `O(N)`의 시간복잡도  

이를 해결하기 위해 비선형 자료구조를 만들어 활용 (단, 저장되어 있는 모습은 선형 자료구조 - 배열 형태이지만)  

트리 중 루트 노드와 비교해 더 작은 값은 왼쪽 자식, 더 큰 값은 오른쪽 자식으로 들어감  
-> `O(logN)`의 시간복잡도로 탐색할 수 있다.  

만약 key를 갖고 있다면, 몇 번씩이나 순회하지 않고 `O(1)`로 찾아가면 됨  

단순히 h만 삽입하는 것이 아니라, 7이라는 key를 함께 업로드 해주면 - 그 key 값에 해당하는 value, h를 뽑아낼 수 있음  

이와 같이, key와 value가 짝지어 있는 자료구조가 hash table  

결국 중요한 것은, data의 크기가 너무 클 때 선형 탐색으로는 시간이 오래 걸리니까 -> 시간복잡도를 줄이기 위한 방법들  

# 해시  
: 데이터를 고정된 크기의 값으로 변환하는 과정  
결국은 `입력값 -> 해시값`으로 변환하는 **"해시 함수"**가 가장 중요함  

해시 함수가 잘 만들어지지 않았다면 - 서로 다른 키가 들어와도 같은 해시값을 반환하는 **"해시 충돌"**이 발생할 수 있음  

단점은, 메모리 사용량이 커진다는 것 - 그래서 <뱀> 문제에서 메모리가 줄어들지 않은 것 같음  

## 해시 함수  
### 좋은 해시 함수란  
* 균등한 분포: prime number - 최대한 균등하게 나누어질 수 있음(1과 자기 자신만 약수로 갖기 때문에)  
* 눈사태 효과: 입력의 작은 변화가 출력의 큰 변화를 야기해야 함  
  => 유사한 입력들이 다른 해시 값을 갖게 하여 클러스터링 방지  
* 효율성: 계산 속도가 빨라야 함  
* 저항성: 입력값을 예상하기 어려워야 함  

- 코드들은 대표적인 hash funcs  

Q)  
그럼 결국은 key를 갖고 있어야지만 O(1)인 거지?  

### Division Hash Function  
: 가장 기본적인 방식으로, 충분히 큰 prime을 table 크기로 가짐(prime인 것은 권장)  
value를 해당 prime으로 나눈 값을 key로 갖도록 함  

### MAD  
연산을 한 값을 prime으로 나누어 Division Hash Function의 문제를 해결  

### Multiplication Hash Function  
: key를 [0~1] 실수로 변환해 이를 해시 테이블의 크기와 곱해 -> 해시 값을 생성  
* 키의 분포에 덜 민감함  
* 고르게 분포  

### Folding Hash Function  
: 키를 여러 부분으로 나누고, 이 부분들을 조합해 최종 해시 값을 생성  
* 키의 모든 부분이 최종 해시 값에 기여 => 균일한 분포  
* 입력값이 긴 경우에 활용할 수 있음  

### Polynomial Hash Function  
: 문자열을 다항식으로 표현해 해시 값을 계산  
* 문자열 처리에 유용  
* rabin-karp에서 사용되며, DB의 index에도 사용됨  

### Secure Hash Algorithm 256-bit  
: 임의의 길이의 입력 데이터  
현재 잘 쓰이고 있음  

Q)  
key와 hash값을 혼동하고 있는 것 같음  

## 해시 충돌  
이미 어떠한 값이 있는데, A를 같이 때려박음  
### 체이닝(Chaining)  
: 해시 테이블에서 충돌을 해결하는 가장 일반적인 방법  
* 해시 테이블의 각 버킷에 연결 리스트를 사용해 충돌 발생한 항목 저장  
=> 메모리가 많이 쓰이겠죠  

### 주소 개방법(Open Addressing)  
: 키-값 쌍을 해시 테이블 배열 내에 직접 저장, 충돌이 발생하면 다른 빈 슬롯을 찾아 데이터를 저장  
빈 슬롯을 결정하는 방법이 여러가지  
**선형 탐사** - 바로 다음 슬롯으로  
  **이 때의 문제점**: 2가 여러 개 들어왔다면, 2, 3, 4, 5, 6... 순차적으로 들어간다.  
    이후에 3이 들어온다면 얼마나 멀리갈지 알 수 없음. = 비효율적이다. => 캐시 성능이 좋지 않음   

**제곱 탐사** - 기존에 넣으려던 key의 제곱값에 삽입  
그나마 동일한 수의 2들이 계속 나오지만, 선형 탐사마냥 2, 3, 4, 5, 6이 2때문에 2n번으로 밀려날 일은 X  
따라서, 충돌 해결 능력이 향상되며, 캐시 성능이 좋음(연속된 메모리)  

해시 테이블을 재정의하는 과정은 한 번 하면 되지만, 해시 테이블을 만들면 O(1)만에 찾을 수 있기 때문에 - 다시 만드는 데 시간이 걸려도 그냥 진행  

**이중 해싱** - 두 개의 해시 함수를 사용함: 첫 번째로 클러스터링 발생하지 않도록 해놔도 두 번째 해시 함수에 의해 클러스터링 발생할 수도 있음  

