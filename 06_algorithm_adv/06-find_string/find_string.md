# 브루트포스 알고리즘  
한 칸씩 이동하면서 찾고자 하는 문자열(key)과 비교  

어딘가에 시작 지점 등을 기록해두고, 필요할 경우 돌아가도록 함  

two-pointer를 사용하도록  

* 시간복잡도: `O(N * M)`  
너무 느리다!  

# 라빈-카프 알고리즘  
문자열 검색을 위해 해시 값 함수를 사용함  
정수는 아무리 길어도 두 개의 값을 비교했을 때 값의 일치 여부를 바로 return할 수 있음  
따라서, 해시를 사용해 문자열을 정수로 만들어주어 값을 비교  

## 문자열을 숫자로 만드는 방법  
: 패턴의 해쉬값을 계산  
같은 자리수끼리 비교할 수 있도록  
10의 n-1승 번째의 값을 빼줌  

prime으로 나눈 나머지 값을 사용하자 : 여기서 prime은 충분히 큰 소수(최대한 중복되지 않는 값들을 갖게 하기 위함)  
왜냐하면, 큰 정수 값을 전부 다 사용할 필요가 없기 때문에  

나머지 연산을 하는 과정에서 -> 1이라는 정수 key에 A, f가 같이 들어왔을 수도 있다.  
: 해쉬 충돌 => 내일 배움  

영역의 특정 범위와 패턴이 동일한지 확인한다.  

** 복습해야 함  

# 보이어-무어 알고리즘  
in 연산자의 시간복잡도는 O(N)  

`python - string`의 `find` 메소드는 보이어-무어 알고리즘을 사용함  
찾고자 하는 문자열 길이가 1이면, 보이어-무어 등으로 찾는 것보다 훨씬 빠르게 동작하는 find 메소드  
길이가 1 초과이면, for문이 더 빠를 수 있음  

보이어-무어의 핵심적인 과정은  
* 오른쪽에서 왼쪽으로 문자열 비교  
: 건너뛰어서 오른쪽부터 조사함  
오른쪽 끝에 있는 문자가 불일치하고, 이 문자가 패턴 내에 존재하지 않는 경우, 이동 거리는 무려 패턴의 길이만큼이 됨  
* 최악의 시간 복잡도는 `O(M * N)` 이지만, 패턴 길이만큼 skip 하기 때문에 최선의 시간 복잡도는 `O(N/M)`  

현재 찾고 있는 패턴에 포함된 문자가 전체 text에 있다면, 패턴에 일치하는 문자를 찾아 딱 그 만큼만 skip  
skip 배열을 통해 끝에서부터 얼만큼 skip 해야하는지  

# KMP 알고리즘  
a, b, c, d가 등장하는 위치만큼 똑같이 skip(브루트포스부터)  
접두와 접미 & 부분문자열을 활용해서 문자열을 비교함  

접두와 접미가 일치하는 지를 확인하기 위한 것  
